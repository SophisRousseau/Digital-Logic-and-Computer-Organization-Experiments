### 1  实验目的

掌握几种常用的多路选择器的设计方法。

掌握 Verilog 语言中的 always 语句块、if-else 语句和 case 语句的使用等。

最后自行设计一个多路选择器(4 选 1 多路选择器)，熟悉电路设计的基本流程和 Vivado 的使用。

### 2  实验原理

4 选 1 多路选择器的模块图和真值表如图所示，$a_0-a_3$ 为 4 个输入端，$s_0$ 和 $s_1$ 是选择端，$y$ 是输出端，根据 $s_0$ 和 $s_1$ 值的不同，$y$ 选择 $a_0-a_3$ 中的一个输出。Verilog 语言中的 case 语句可以综合出 “多路复用器” 的电路。

<img src="C:\Users\Sophie\AppData\Roaming\Typora\typora-user-images\image-20230319183108833.png" title="image" width="200"/>

<center>原理图</center>

$$
\begin{array}{ll|l}
\mathrm{s}_0 & \mathrm{~s}_1 & \mathrm{y} \\
\hline 0 & 0 & \mathrm{a}_0 \\
0 & 1 & \mathrm{a}_1 \\
1 & 0 & \mathrm{a}_2 \\
1 & 1 & \mathrm{a}_3
\end{array}
$$


<center>真值表</center>

### 3  实验环境/器材

##### 软件环境

- Vivado 2022.1

##### 硬件器材

- 开发板：Digilent Nexys A7-100T
- FPGA：XC7A100T-1CSG324C

### 4  程序代码或流程图

#### 4.1  电路原理图

<img src='C:\Users\Sophie\AppData\Roaming\Typora\typora-user-images\image-20230319192707941.png' width = 400>

<center>4:1 多路选择器电路原理图

#### 4.2  程序代码

如下 Verilog 代码定义了一个 4:1 多路选择器，其输入为 2 位，输出为 2 位。输入 `X0`、`X1`、`X2` 和 `X3` 表示要由控制输入 `Y` 选择的 2 位输入值。输出 `F` 表示多路选择器的 2 位输出值。`F` 被声明为两位的 `wire` 向量。因此，该代码使用两个 `assign` 语句来实现多路选择器。第一个 `assign` 语句实现了输出的最低有效位 `F[0]` 的选择逻辑，而第二个 `assign` 语句实现了输出的最高有效位 `F[1]` 的选择逻辑。除了这种实现方式外，还可以用 Verilog 提供的 `case` 语句来实现 4:1 多路选择器，但是要把 `F` 声明为两位的 `reg` 向量。

```verilog
`timescale 1ns / 1ps

 module mux41(
	input [1:0] X0,
	input [1:0] X1,
	input [1:0] X2,
	input [1:0] X3,
	input [1:0] Y,
	output [1:0] F
	);

assign F[0]=(~Y[0]&~Y[1]&X0[0])|(Y[0]&~Y[1]&X1[0])|(~Y[0]&Y[1]&X2[0])|(Y[0]&Y[1]&X3[0]);
assign F[1]=(~Y[0]&~Y[1]&X0[1])|(Y[0]&~Y[1]&X1[1])|(~Y[0]&Y[1]&X2[1])|(Y[0]&Y[1]&X3[1]);

endmodule
```

### 5  实验步骤/过程

#### 5.1  编写设计文件

编写 Verilog 设计文件并进行综合，生成网表文件。设计文件的内容已在第 4 部分展示。

#### 5.2  验证综合后生成的电路原理图是否正确

综合后生成的电路原理图已在第 4 部分展示，已验证电路图为正确。

#### 5.3  编写仿真文件，进行仿真测试

如下 Verilog 代码定义了一个测试模块 `mux41_test`，用于测试一个 4:1 的多路选择器，具有两位输入和两位输出。输入 `X0`、`X1`、`X2` 和 `X3` 分别代表多路选择器中的四个输入，由控制输入 `Y` 进行选择。输出 `F` 表示多路选择器的输出值。`initial` 块包含了一些测试用例。首先将输入 `X0`、`X1`、`X2`、`X3` 和 `Y` 的初始值设为 0，1，2，3 和 0。然后通过一系列时间延迟和输入值的更改，测试多路选择器的不同输入和输出情况。

仿真测试结果将在第 7 部分展示。

```verilog
`timescale 1ns / 1ps

module mux41_test(); 

reg [1:0] X0;
reg [1:0] X1;
reg [1:0] X2;
reg [1:0] X3;
reg [1:0] Y;
wire [1:0] F; 

mux41 i1 (
    .X0(X0),
	.X1(X1),
	.X2(X2),
	.X3(X3),
	.Y(Y),
	.F(F)
	);
initial 
begin

    X0=0; X1=1; X2=2; X3=3; Y=0;
#10 X0=1; X1=0; X2=2; X3=3; Y=0;
#10 X0=0; X1=1; X2=2; X3=3; Y=1;
#10 X0=0; X1=2; X2=1; X3=3; Y=1;
#10 X0=0; X1=1; X2=2; X3=3; Y=2;
#10 X0=0; X1=1; X2=3; X3=2; Y=2;
#10 X0=0; X1=1; X2=2; X3=3; Y=3;
#10 X0=3; X1=1; X2=2; X3=0; Y=3;

end
endmodule
```

#### 5.4  综合和实现后生成比特流文件，并下载到目标 FPGA 芯片进行验证

本过程已线下验收，未出现任何失误。

### 6  测试方法

验证设计结果为正确的方法主要包括如下三种：

- 验证综合生成的电路原理图是否正确。
- 编写仿真文件对设计文件进行仿真测试。
- 把综合和实现后生成的比特流文件下载到目标 FPGA 芯片进行验证。

在仿真测试和下载运行过程中，通过改变多路选择器的四个输入值 `X0`、`X1`、`X2` 、`X3 ` 和控制信号 `Y`，观察输出结果 `F` 是否按照预期的结果输出，即可验证设计文件是否正确。

### 7  实验结果

![image-20230319191534376](C:\Users\Sophie\AppData\Roaming\Typora\typora-user-images\image-20230319191534376.png)

<center>仿真测试结果</center>

本实验已线下验收，未出现任何失误，因此这里省略了下载运行结果。

### 8  实验中遇到的问题及解决办法

本次实验较为简单，尚未遇到任何问题。

### 9  实验得到的启示

主要是 `wire` 和 `reg` 的区别：

- `reg` 不能被 `assign` 赋值，只能在单个 `always` 块内被 `=` 赋值。
- `wire` 只能被 `assign` 赋值一次，且不能在 `always` 块内被赋值。
- `reg` 和 `wire` 都可以被用于各类赋值的右值。

- 子模块的输入只能定义为 `wire` 型，但是调用的父模块可以用 `wire` 或者 `reg` 驱动。
-  子模块的输出可以是 `reg` 或 `wire` 型，但是调用的父模块一定要用 `wire` 型来接受输出。

